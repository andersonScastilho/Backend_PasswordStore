"use strict";var m=Object.create;var i=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var l=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,U=Object.prototype.hasOwnProperty;var y=(r,s)=>{for(var e in s)i(r,e,{get:s[e],enumerable:!0})},w=(r,s,e,t)=>{if(s&&typeof s=="object"||typeof s=="function")for(let o of l(s))!U.call(r,o)&&o!==e&&i(r,o,{get:()=>s[o],enumerable:!(t=P(s,o))||t.enumerable});return r};var E=(r,s,e)=>(e=r!=null?m(g(r)):{},w(s||!r||!r.__esModule?i(e,"default",{value:r,enumerable:!0}):e,r)),R=r=>w(i({},"__esModule",{value:!0}),r);var f={};y(f,{CreateUser:()=>d});module.exports=R(f);var h=require("uuid");var u=E(require("bcrypt")),p=class{get userEmail(){return this.props.userEmail}get userFullName(){return this.props.userFullName}get userPassword(){return this.props.userPassword}get userId(){return this.props.userId}set hashPasswordToUserPassword(s){this.props.userPassword=s}set updateUserFullName(s){this.props.userFullName=s}set updateUserEmail(s){this.props.userEmail=s}constructor(s){this.props=s}async encryptedPassword(s){return await u.default.hash(s,10)}async comparePasswords(s){return await u.default.compare(s,this.userPassword)}async updatePassword(s,e,t){if(!await this.comparePasswords(s))throw Error("Invalid password");if(e!==t)throw Error("Password confirmation must be the same as password");let n=await this.encryptedPassword(e);this.props.userPassword=n}};var d=class{constructor(s,e){this.createUserRepository=s;this.showUserperEmailRepository=e}async execute({userEmail:s,userFullName:e,userPassword:t}){if(await this.showUserperEmailRepository.show(s))throw Error("Email in use");let n=(0,h.v4)(),a=new p({userEmail:s,userFullName:e,userId:n,userPassword:t}),c=await a.encryptedPassword(t);return a.hashPasswordToUserPassword=c,await this.createUserRepository.create(a),a}};0&&(module.exports={CreateUser});
