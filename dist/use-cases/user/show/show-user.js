"use strict";var w=Object.create;var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var c=Object.getOwnPropertyNames;var l=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var P=(e,s)=>{for(var r in s)a(e,r,{get:s[r],enumerable:!0})},u=(e,s,r,o)=>{if(s&&typeof s=="object"||typeof s=="function")for(let t of c(s))!m.call(e,t)&&t!==r&&a(e,t,{get:()=>s[t],enumerable:!(o=h(s,t))||o.enumerable});return e};var g=(e,s,r)=>(r=e!=null?w(l(e)):{},u(s||!e||!e.__esModule?a(r,"default",{value:e,enumerable:!0}):r,e)),U=e=>u(a({},"__esModule",{value:!0}),e);var y={};P(y,{ShowUser:()=>n});module.exports=U(y);var p=g(require("bcrypt")),i=class{get userEmail(){return this.props.userEmail}get userFullName(){return this.props.userFullName}get userPassword(){return this.props.userPassword}get userId(){return this.props.userId}set hashPasswordToUserPassword(s){this.props.userPassword=s}set updateUserFullName(s){this.props.userFullName=s}set updateUserEmail(s){this.props.userEmail=s}constructor(s){this.props=s}async encryptedPassword(s){return await p.default.hash(s,10)}async comparePasswords(s){return await p.default.compare(s,this.userPassword)}async updatePassword(s,r,o){if(!await this.comparePasswords(s))throw Error("Invalid password");if(r!==o)throw Error("Password confirmation must be the same as password");let d=await this.encryptedPassword(r);this.props.userPassword=d}};var n=class{constructor(s){this.showUserRepository=s}async execute(s){let r=await this.showUserRepository.show(s);if(!r)throw Error("User not found");return new i({userEmail:r.email,userFullName:r.fullName,userId:r.id,userPassword:r.password_hash})}};0&&(module.exports={ShowUser});
