"use strict";var m=Object.create;var d=Object.defineProperty;var c=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var U=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(e,s)=>{for(var r in s)d(e,r,{get:s[r],enumerable:!0})},l=(e,s,r,a)=>{if(s&&typeof s=="object"||typeof s=="function")for(let t of P(s))!g.call(e,t)&&t!==r&&d(e,t,{get:()=>s[t],enumerable:!(a=c(s,t))||a.enumerable});return e};var y=(e,s,r)=>(r=e!=null?m(U(e)):{},l(s||!e||!e.__esModule?d(r,"default",{value:e,enumerable:!0}):r,e)),I=e=>l(d({},"__esModule",{value:!0}),e);var E={};f(E,{UpdateUser:()=>w});module.exports=I(E);var n=y(require("bcrypt")),u=class{get userEmail(){return this.props.userEmail}get userFullName(){return this.props.userFullName}get userPassword(){return this.props.userPassword}get userId(){return this.props.userId}set hashPasswordToUserPassword(s){this.props.userPassword=s}set updateUserFullName(s){this.props.userFullName=s}set updateUserEmail(s){this.props.userEmail=s}constructor(s){this.props=s}async encryptedPassword(s){return await n.default.hash(s,10)}async comparePasswords(s){return await n.default.compare(s,this.userPassword)}async updatePassword(s,r,a){if(!await this.comparePasswords(s))throw Error("Invalid password");if(r!==a)throw Error("Password confirmation must be the same as password");let p=await this.encryptedPassword(r);this.props.userPassword=p}};var w=class{constructor(s,r){this.showUserPerUserIdRepository=s;this.updateUserRepository=r}async handle({userId:s,email:r,fullName:a,oldPassword:t,newPassword:p,newPasswordConfirmation:h}){let i=await this.showUserPerUserIdRepository.show(s);if(!i)throw Error("User not found");let o=new u({userId:i.id,userEmail:i.email,userFullName:i.fullName,userPassword:i.password_hash});return a&&(o.updateUserFullName=a),p&&t&&h&&await o.updatePassword(t,p,h),r&&(o.updateUserEmail=r),await this.updateUserRepository.update({userId:o.userId,email:o.userEmail,fullName:o.userFullName,newPassword:o.userPassword})}};0&&(module.exports={UpdateUser});
