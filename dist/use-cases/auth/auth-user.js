"use strict";var I=Object.create;var n=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var U=Object.getOwnPropertyNames;var T=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var k=(e,s)=>{for(var r in s)n(e,r,{get:s[r],enumerable:!0})},l=(e,s,r,o)=>{if(s&&typeof s=="object"||typeof s=="function")for(let t of U(s))!v.call(e,t)&&t!==r&&n(e,t,{get:()=>s[t],enumerable:!(o=g(s,t))||o.enumerable});return e};var u=(e,s,r)=>(r=e!=null?I(T(e)):{},l(s||!e||!e.__esModule?n(r,"default",{value:e,enumerable:!0}):r,e)),N=e=>l(n({},"__esModule",{value:!0}),e);var x={};k(x,{AuthUser:()=>h});module.exports=N(x);var c=u(require("bcrypt")),p=class{get userEmail(){return this.props.userEmail}get userFullName(){return this.props.userFullName}get userPassword(){return this.props.userPassword}get userId(){return this.props.userId}set hashPasswordToUserPassword(s){this.props.userPassword=s}set updateUserFullName(s){this.props.userFullName=s}set updateUserEmail(s){this.props.userEmail=s}constructor(s){this.props=s}async encryptedPassword(s){return await c.default.hash(s,10)}async comparePasswords(s){return await c.default.compare(s,this.userPassword)}async updatePassword(s,r,o){if(!await this.comparePasswords(s))throw Error("Invalid password");if(r!==o)throw Error("Password confirmation must be the same as password");let i=await this.encryptedPassword(r);this.props.userPassword=i}};var a=u(require("jsonwebtoken")),w=class{constructor(s){this.showUserPerUserIdRepository=s}async validAuth(s){let[,r]=s.split(" ");if(!a.default.verify(r,process.env.TOKEN_SECRET??""))throw Error("Invalid token");let{id:t,email:i}=a.default.verify(r,process.env.TOKEN_SECRET??""),d=await this.showUserPerUserIdRepository?.show(t);if(i!==d?.email)throw Error("Invalid token");return t}async authentication(s,r){if(!await s.comparePasswords(r))throw Error("Invalid password");return a.default.sign({id:s.userId,email:s.userEmail},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}async authenticationProvider(s,r){return a.default.sign({id:s,email:r},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}},m=w;var P=u(require("dayjs")),f=require("uuid"),h=class{constructor(s,r,o){this.showUserPerEmailRepository=s;this.createRefreshTokenRepository=r;this.deleteRefreshTokenRepository=o}async execute({email:s,password:r}){let o=await this.showUserPerEmailRepository.show(s);if(!o)throw Error("User not found");let t=new p({userEmail:o.email,userFullName:o.fullName,userId:o.id,userPassword:o.password_hash}),i=new m;await this.deleteRefreshTokenRepository.delete(o.id);let d=await i.authentication(t,r),y=(0,f.v4)(),E=(0,P.default)().add(7,"days").unix(),R=await this.createRefreshTokenRepository.create({expiresIn:E,id:y,userId:t.userId});return{token:d,refreshToken:R}}};0&&(module.exports={AuthUser});
