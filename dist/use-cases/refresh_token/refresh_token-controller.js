"use strict";var E=Object.create;var p=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,S=Object.prototype.hasOwnProperty;var x=(o,e)=>{for(var r in e)p(o,r,{get:e[r],enumerable:!0})},u=(o,e,r,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of P(e))!S.call(o,s)&&s!==r&&p(o,s,{get:()=>e[s],enumerable:!(t=T(e,s))||t.enumerable});return o};var y=(o,e,r)=>(r=o!=null?E(v(o)):{},u(e||!o||!o.__esModule?p(r,"default",{value:o,enumerable:!0}):r,o)),g=o=>u(p({},"__esModule",{value:!0}),o);var _={};x(_,{RefreshTokenController:()=>l});module.exports=g(_);var d=y(require("dayjs"));var n=y(require("jsonwebtoken")),w=class{constructor(e){this.showUserPerUserIdRepository=e}async validAuth(e){let[,r]=e.split(" ");if(!n.default.verify(r,process.env.TOKEN_SECRET??""))throw Error("Invalid token");let{id:s,email:a}=n.default.verify(r,process.env.TOKEN_SECRET??""),i=await this.showUserPerUserIdRepository?.show(s);if(!i)throw Error("User not found");if(a!==i.email)throw Error("Invalid token");return s}async authentication(e,r){if(!await e.comparePasswords(r))throw Error("Invalid password");return n.default.sign({id:e.userId,email:e.userEmail},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}async authenticationProvider(e,r){return n.default.sign({id:e,email:r},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}},k=w;var h=class{constructor(e,r){this.showRefreshTokenRepository=e;this.showUserPerUserIdRepository=r}async execute(e){let r=await this.showRefreshTokenRepository.show(e);if(!r)throw Error("Refresh token invalid");let t=await this.showUserPerUserIdRepository.show(r.userId);if(!t)throw Error("User not found");if(t.verifiedEmail!==!0)throw Error("Unverified email");let s=new k;if((0,d.default)().isAfter(d.default.unix(r.expiresIn)))throw Error("Refresh_token expired");return await s.authenticationProvider(r.userId,t.email)}};var U=require("@prisma/client"),m=new U.PrismaClient;var c=class{async show(e){return await m.refresh_Token.findFirst({where:{id:e}})}};var R=require("zod");var f=class{async show(e){return await m.user.findUnique({where:{id:e}})}};var N=R.z.object({refresh_token:R.z.string()}),l=class{async handle(e,r,t){try{let{refresh_token:s}=N.parse(e.body),a=new c,i=new f,I=await new h(a,i).execute(s);return r.status(200).json({token:I})}catch(s){t(s)}}};0&&(module.exports={RefreshTokenController});
