"use strict";var tt=Object.create;var x=Object.defineProperty;var ot=Object.getOwnPropertyDescriptor;var rt=Object.getOwnPropertyNames;var et=Object.getPrototypeOf,st=Object.prototype.hasOwnProperty;var at=(s,t)=>{for(var o in t)x(s,o,{get:t[o],enumerable:!0})},D=(s,t,o,e)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of rt(t))!st.call(s,r)&&r!==o&&x(s,r,{get:()=>t[r],enumerable:!(e=ot(t,r))||e.enumerable});return s};var V=(s,t,o)=>(o=s!=null?tt(et(s)):{},D(t||!s||!s.__esModule?x(o,"default",{value:s,enumerable:!0}):o,s)),nt=s=>D(x({},"__esModule",{value:!0}),s);var yt={};at(yt,{storageRoutes:()=>l});module.exports=nt(yt);var W=require("express");var G=require("uuid");var I=V(require("crypto")),J="aes-256-gcm",M=Buffer.from(process.env.SECRET_CRYPTO??"","hex"),$=I.default.randomBytes(16),X=s=>{try{let t=I.default.createCipheriv(J,M,$),o=Buffer.concat([t.update(s.toString()),t.final()]),e=t.getAuthTag();return{iv:$.toString("hex"),content:o.toString("hex"),tag:e.toString("hex")}}catch{throw Error("Erro ao criptografar os dados")}},Y=s=>{try{let t=I.default.createDecipheriv(J,M,Buffer.from(s.iv,"hex"));t.setAuthTag(Buffer.from(s.tag,"hex"));let o=Buffer.from(s.content,"hex");return Buffer.concat([t.update(o),t.final()]).toString("utf8")}catch{throw new Error("Erro ao descriptografar os dados.")}};var d=class{get storageId(){return this.props.storageId}get password(){return this.props.password}get account(){return this.props.account}get usageLocation(){return this.props.usageLocation}get link(){return this.props.link}get description(){return this.props.description}get userId(){return this.props.userId}set updatePassword(t){this.props.password=t}constructor(t){this.props=t}showPassword(t){let[o,e,r]=t.split(":");return Y({iv:o,content:e,tag:r})}};var P=class{constructor(t){this.storageRepository=t}async execute({account:t,password:o,usageLocation:e,description:r,link:a,userId:n}){let i=(0,G.v4)(),{iv:g,content:p,tag:w}=X(o),R=`${g}:${p}:${w}`,h=new d({password:R,account:t,usageLocation:e,description:r,link:a,userId:n,storageId:i});return await this.storageRepository.create(h),h.updatePassword="",h}};var H=require("@prisma/client"),c=new H.PrismaClient;var v=class{async create(t){let{account:o,description:e,link:r,password:a,usageLocation:n,userId:i,storageId:g}=t,p=await c.storage.create({data:{account:o,id:g,password:a,usageLocation:n,description:e,link:r,userId:i}});if(!p)throw Error("N\xE3o foi possivel armazenar os dados");return p}};var u=require("zod"),it=u.z.object({password:u.z.string(),account:u.z.string(),usageLocation:u.z.string(),link:u.z.string(),description:u.z.string()}),pt=u.z.object({userId:u.z.string()}),E=class{async handle(t,o,e){try{let{password:r,account:a,usageLocation:n,link:i,description:g}=it.parse(t.body),{userId:p}=pt.parse(t.params),w=new v,h=await new P(w).execute({account:a,password:r,usageLocation:n,description:g,link:i,userId:p});return o.status(200).json(h)}catch(r){e(r)}}};var C=class{async show(t){return await c.user.findUnique({where:{id:t}})}};var y=V(require("jsonwebtoken")),K=class{constructor(t){this.showUserPerUserIdRepository=t}async validAuth(t){let[,o]=t.split(" ");if(!y.default.verify(o,process.env.TOKEN_SECRET??""))throw Error("Invalid token");let{id:r,email:a}=y.default.verify(o,process.env.TOKEN_SECRET??""),n=await this.showUserPerUserIdRepository?.show(r);if(!n)throw Error("User not found");if(a!==n.email)throw Error("Invalid token");return r}async authentication(t,o){if(!await t.comparePasswords(o))throw Error("Invalid password");return y.default.sign({id:t.userId,email:t.userEmail},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}async authenticationProvider(t,o){return y.default.sign({id:t,email:o},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}},Q=K;var f=async(s,t,o)=>{let{authorization:e}=s.headers;try{let r=new C;if(!e)return t.status(401).json({errors:["Login required"]});let n=await new Q(r).validAuth(e);return s.params={...s.params,userId:n},o()}catch{return t.status(401).json({error:"Token expired or invalid"})}};var U=class{async index(t){return await c.storage.findMany({where:{userId:t}})}};var k=class{constructor(t){this.indexStorageRepository=t}async execute(t){let o=await this.indexStorageRepository.index(t),e=[];return o.forEach(r=>{let a=new d({account:r.account,password:"",storageId:r.id,usageLocation:r.usageLocation,userId:r.userId,description:r.description||void 0,link:r.link||void 0});e.push(a)}),e}};var _=require("zod"),ct=_.z.object({userId:_.z.string()}),N=class{async handle(t,o,e){try{let{userId:r}=ct.parse(t.params);if(!r)return o.status(401).json({error:"Login required"});let a=new U,i=await new k(a).execute(r);return o.status(200).json({storages:i})}catch(r){e(r)}}};var S=class{async show(t,o){return await c.storage.findFirst({where:{AND:{id:t,userId:o}}})}};var L=class{constructor(t){this.showStorageRepository=t}async execute(t,o){let e=await this.showStorageRepository.show(t,o);if(!e)throw Error("Storage not found");return new d({account:e.account,password:"",storageId:e.id,usageLocation:e.usageLocation,userId:e.userId,description:e.description||"",link:e.link||""})}};var j=require("zod"),gt=j.z.object({storageId:j.z.string(),userId:j.z.string()}),T=class{async handle(t,o,e){try{let{storageId:r,userId:a}=gt.parse(t.params),n=new S,g=await new L(n).execute(r,a);return o.status(200).json(g)}catch(r){e(r)}}};var q=class{async update({account:t,description:o,link:e,usageLocation:r,storageId:a,password:n}){return await c.storage.update({where:{id:a},data:{account:t,description:o,link:e,usageLocation:r,password:n}})}};var F=class{constructor(t,o){this.updateStorageReposirory=t;this.showStorageRepository=o}async execute({storageId:t,account:o,description:e,link:r,usageLocation:a,userId:n,password:i}){if(!await this.showStorageRepository.show(t,n))throw Error("Storage not found");let p=await this.updateStorageReposirory.update({storageId:t,account:o,userId:n,description:e,link:r,usageLocation:a,password:i});return new d({account:p.account,password:"",storageId:p.id,usageLocation:p.usageLocation,userId:p.userId,description:p.description||"",link:p.link||""})}};var m=require("zod"),dt=m.z.object({account:m.z.string().optional(),usageLocation:m.z.string().optional(),description:m.z.string().optional(),link:m.z.string().optional(),password:m.z.string().optional()}),mt=m.z.object({userId:m.z.string(),storageId:m.z.string()}),b=class{async handle(t,o,e){try{let{account:r,usageLocation:a,description:n,link:i,password:g}=dt.parse(t.body),{userId:p,storageId:w}=mt.parse(t.params);if(!r&&!a&&!n&&!i)return o.status(400).json({error:"Missing data"});let R=new q,h=new S,Z=await new F(R,h).execute({account:r,storageId:w,userId:p,description:n,link:i,usageLocation:a,password:g});return o.status(200).json({storage:Z})}catch(r){e(r)}}};var B=class{async delete(t){await c.storage.delete({where:{id:t}})}};var O=class{constructor(t,o){this.deleteStorageRepository=t;this.showStorageRepository=o}async execute(t,o){if(!await this.showStorageRepository.show(t,o))throw Error("Storage not found");await this.deleteStorageRepository.delete(t)}};var A=require("zod"),ut=A.z.object({userId:A.z.string(),storageId:A.z.string()}),z=class{async handle(t,o,e){try{let{userId:r,storageId:a}=ut.parse(t.params),n=new B,i=new S;return await new O(n,i).execute(a,r),o.status(200).json({})}catch(r){e(r)}}};var St=new E,ht=new N,wt=new T,ft=new b,lt=new z,l=(0,W.Router)();l.post("/storages",f,St.handle);l.get("/storages",f,ht.handle);l.get("/storages/:storageId",f,wt.handle);l.put("/storages/:storageId",f,ft.handle);l.delete("/storages/:storageId",f,lt.handle);0&&(module.exports={storageRoutes});
