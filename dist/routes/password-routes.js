"use strict";var N=Object.create;var d=Object.defineProperty;var O=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var B=Object.getPrototypeOf,_=Object.prototype.hasOwnProperty;var j=(s,r)=>{for(var o in r)d(s,o,{get:r[o],enumerable:!0})},P=(s,r,o,e)=>{if(r&&typeof r=="object"||typeof r=="function")for(let t of A(r))!_.call(s,t)&&t!==o&&d(s,t,{get:()=>r[t],enumerable:!(e=O(r,t))||e.enumerable});return s};var f=(s,r,o)=>(o=s!=null?N(B(s)):{},P(r||!s||!s.__esModule?d(o,"default",{value:s,enumerable:!0}):o,s)),K=s=>P(d({},"__esModule",{value:!0}),s);var z={};j(z,{passwordRoutes:()=>k});module.exports=K(z);var T=require("express");var R=require("@prisma/client"),g=new R.PrismaClient;var u=class{async show(r,o){return await g.storage.findFirst({where:{AND:{id:r,userId:o}}})}};var l=f(require("crypto")),L="aes-256-gcm",V=Buffer.from(process.env.SECRET_CRYPTO??"","hex"),G=l.default.randomBytes(16);var U=s=>{try{let r=l.default.createDecipheriv(L,V,Buffer.from(s.iv,"hex"));r.setAuthTag(Buffer.from(s.tag,"hex"));let o=Buffer.from(s.content,"hex");return Buffer.concat([r.update(o),r.final()]).toString("utf8")}catch{throw new Error("Erro ao descriptografar os dados.")}};var m=class{get storageId(){return this.props.storageId}get password(){return this.props.password}get account(){return this.props.account}get usageLocation(){return this.props.usageLocation}get link(){return this.props.link}get description(){return this.props.description}get userId(){return this.props.userId}set updatePassword(r){this.props.password=r}constructor(r){this.props=r}showPassword(r){let[o,e,t]=r.split(":");return U({iv:o,content:e,tag:t})}};var E=f(require("bcrypt")),w=class{constructor(r,o){this.showStorageRepository=r;this.showUserPerUserIdRepository=o}async execute(r,o,e){let t=await this.showStorageRepository.show(r,o);if(!t)throw Error("Storage not found");let n=new m({account:t.account,password:t.password,storageId:t.id,usageLocation:t.usageLocation,userId:t.userId,description:t.description??"",link:t.link??""}),i=await this.showUserPerUserIdRepository.show(o);if(!i)throw Error("User not found");if(!await E.default.compare(e,i.password_hash))throw Error("Invalid password");return n.showPassword(n.password)}};var a=class{async show(r){return await g.user.findUnique({where:{id:r}})}};var p=require("zod"),F=p.z.object({password:p.z.string()}),b=p.z.object({storageId:p.z.string(),userId:p.z.string()}),h=class{async handle(r,o,e){try{let{password:t}=F.parse(r.body),{storageId:n,userId:i}=b.parse(r.params);if(!t)return o.status(400).json({error:"Missing data"});let I=new u,S=new a,C=await new w(I,S).execute(n,i,t);return o.status(200).json({descryptedPassword:C})}catch(t){e(t)}}};var c=f(require("jsonwebtoken")),y=class{constructor(r){this.showUserPerUserIdRepository=r}async validAuth(r){let[,o]=r.split(" ");if(!c.default.verify(o,process.env.TOKEN_SECRET??""))throw Error("Invalid token");let{id:t,email:n}=c.default.verify(o,process.env.TOKEN_SECRET??""),i=await this.showUserPerUserIdRepository?.show(t);if(n!==i?.email)throw Error("Invalid token");return t}async authentication(r,o){if(!await r.comparePasswords(o))throw Error("Invalid password");return c.default.sign({id:r.userId,email:r.userEmail},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}async authenticationProvider(r,o){return c.default.sign({id:r,email:o},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}},v=y;var x=async(s,r,o)=>{let{authorization:e}=s.headers;try{let t=new a;if(!e)return r.status(401).json({errors:["Login required"]});let i=await new v(t).validAuth(e);return s.params={...s.params,userId:i},o()}catch{return r.status(401).json({error:"Token expired or invalid"})}};var k=(0,T.Router)(),q=new h;k.post("/passwords/storages/:storageId",x,q.handle);0&&(module.exports={passwordRoutes});
