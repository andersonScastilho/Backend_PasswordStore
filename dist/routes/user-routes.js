"use strict";var J=Object.create;var U=Object.defineProperty;var X=Object.getOwnPropertyDescriptor;var L=Object.getOwnPropertyNames;var D=Object.getPrototypeOf,G=Object.prototype.hasOwnProperty;var H=(o,r)=>{for(var s in r)U(o,s,{get:r[s],enumerable:!0})},j=(o,r,s,t)=>{if(r&&typeof r=="object"||typeof r=="function")for(let e of L(r))!G.call(o,e)&&e!==s&&U(o,e,{get:()=>r[e],enumerable:!(t=X(r,e))||t.enumerable});return o};var k=(o,r,s)=>(s=o!=null?J(D(o)):{},j(r||!o||!o.__esModule?U(s,"default",{value:o,enumerable:!0}):s,o)),Q=o=>j(U({},"__esModule",{value:!0}),o);var or={};H(or,{userRouter:()=>S});module.exports=Q(or);var K=require("express");var _=require("@prisma/client"),u=new _.PrismaClient;var d=class{async show(r){return await u.user.findUnique({where:{id:r}})}};var c=k(require("jsonwebtoken")),C=class{constructor(r){this.showUserPerUserIdRepository=r}async validAuth(r){let[,s]=r.split(" ");if(!c.default.verify(s,process.env.TOKEN_SECRET??""))throw Error("Invalid token");let{id:e,email:i}=c.default.verify(s,process.env.TOKEN_SECRET??""),a=await this.showUserPerUserIdRepository?.show(e);if(i!==a?.email)throw Error("Invalid token");return e}async authentication(r,s){if(!await r.comparePasswords(s))throw Error("Invalid password");return c.default.sign({id:r.userId,email:r.userEmail},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}async authenticationProvider(r,s){return c.default.sign({id:r,email:s},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}},b=C;var F=async(o,r,s)=>{let{authorization:t}=o.headers;try{let e=new d;if(!t)return r.status(401).json({errors:["Login required"]});let a=await new b(e).validAuth(t);return o.params={...o.params,userId:a},s()}catch{return r.status(401).json({error:"Token expired or invalid"})}};var w=require("zod");var O=require("uuid");var T=k(require("bcrypt")),l=class{get userEmail(){return this.props.userEmail}get userFullName(){return this.props.userFullName}get userPassword(){return this.props.userPassword}get userId(){return this.props.userId}set hashPasswordToUserPassword(r){this.props.userPassword=r}set updateUserFullName(r){this.props.userFullName=r}set updateUserEmail(r){this.props.userEmail=r}constructor(r){this.props=r}async encryptedPassword(r){return await T.default.hash(r,10)}async comparePasswords(r){return await T.default.compare(r,this.userPassword)}async updatePassword(r,s,t){if(!await this.comparePasswords(r))throw Error("Invalid password");if(s!==t)throw Error("Password confirmation must be the same as password");let i=await this.encryptedPassword(s);this.props.userPassword=i}};var f=class{constructor(r,s){this.createUserRepository=r;this.showUserperEmailRepository=s}async execute({userEmail:r,userFullName:s,userPassword:t}){if(await this.showUserperEmailRepository.show(r))throw Error("Email in use");let i=(0,O.v4)(),a=new l({userEmail:r,userFullName:s,userId:i,userPassword:t}),n=await a.encryptedPassword(t);return a.hashPasswordToUserPassword=n,await this.createUserRepository.create(a),a}};var P=class{async create(r){let{userEmail:s,userFullName:t,userPassword:e,userId:i}=r,a=await u.user.create({data:{email:s,fullName:t,id:i,password_hash:e}});if(!a)throw Error("N\xE3o foi possivel criar o usuario");return a}};var y=class{async show(r){return await u.user.findUnique({where:{email:r}})}};var W=w.z.object({email:w.z.string().email(),fullName:w.z.string(),password:w.z.string()}),R=class{async handle(r,s,t){try{let{email:e,fullName:i,password:a}=W.parse(r.body),n=new P,p=new y,h=await new f(n,p).execute({userEmail:e,userFullName:i,userPassword:a});return s.status(200).json({email:h.userEmail,fullName:h.userFullName})}catch(e){t(e)}}};var E=class{constructor(r){this.showUserRepository=r}async execute(r){let s=await this.showUserRepository.show(r);if(!s)throw Error("User not found");return new l({userEmail:s.email,userFullName:s.fullName,userId:s.id,userPassword:s.password_hash})}};var q=require("zod"),Y=q.z.object({userId:q.z.string()}),g=class{async handle(r,s,t){try{let{userId:e}=Y.parse(r.params),i=new d,n=await new E(i).execute(e);return s.status(200).json({email:n.userEmail,fullName:n.userFullName})}catch(e){t(e)}}};var m=require("zod");var I=class{constructor(r,s){this.showUserPerUserIdRepository=r;this.updateUserRepository=s}async handle({userId:r,email:s,fullName:t,oldPassword:e,newPassword:i,newPasswordConfirmation:a}){let n=await this.showUserPerUserIdRepository.show(r);if(!n)throw Error("User not found");let p=new l({userId:n.id,userEmail:n.email,userFullName:n.fullName,userPassword:n.password_hash});return t&&(p.updateUserFullName=t),i&&e&&a&&await p.updatePassword(e,i,a),s&&(p.updateUserEmail=s),await this.updateUserRepository.update({userId:p.userId,email:p.userEmail,fullName:p.userFullName,newPassword:p.userPassword})}};var N=class{async update({email:r,fullName:s,newPassword:t,userId:e}){return await u.user.update({where:{id:e},data:{email:r,fullName:s,password_hash:t}})}};var Z=m.z.object({email:m.z.string().email().optional(),oldPassword:m.z.string().optional(),newPassword:m.z.string().optional(),newPasswordConfirmation:m.z.string().optional(),fullName:m.z.string().optional()}),$=m.z.object({userId:m.z.string()}),x=class{async handle(r,s,t){try{let{email:e,newPassword:i,newPasswordConfirmation:a,oldPassword:n,fullName:p}=Z.parse(r.body),{userId:v}=$.parse(r.params);if(i){if(!a)throw Error("newPasswordConfirmation is required to update password");if(!n)throw Error("oldPassword is required to update password")}if(!e&&!i&&!a&&!n&&!p)throw Error("Missing data");let h=new d,V=new N,A=new I(h,V),{email:z,fullName:M,id:B}=await A.handle({userId:v,email:e,fullName:p,newPassword:i,newPasswordConfirmation:a,oldPassword:n});return s.status(200).json({user:{email:z,fullName:M,id:B}})}catch(e){t(e)}}};var S=(0,K.Router)(),rr=new R,sr=new g,er=new x;S.post("/users",rr.handle);S.get("/users",F,sr.handle);S.put("/users",F,er.handle);0&&(module.exports={userRouter});
