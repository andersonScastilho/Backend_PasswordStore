"use strict";var Xr=Object.create;var C=Object.defineProperty;var Zr=Object.getOwnPropertyDescriptor;var Yr=Object.getOwnPropertyNames;var Gr=Object.getPrototypeOf,Qr=Object.prototype.hasOwnProperty;var Wr=(t,r)=>{for(var e in r)C(t,e,{get:r[e],enumerable:!0})},kr=(t,r,e,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of Yr(r))!Qr.call(t,o)&&o!==e&&C(t,o,{get:()=>r[o],enumerable:!(s=Zr(r,o))||s.enumerable});return t};var U=(t,r,e)=>(e=t!=null?Xr(Gr(t)):{},kr(r||!t||!t.__esModule?C(e,"default",{value:t,enumerable:!0}):e,t)),re=t=>kr(C({},"__esModule",{value:!0}),t);var ve={};Wr(ve,{default:()=>Ne});module.exports=re(ve);var xr=U(require("express"));var Tr=require("express");var Nr=require("@prisma/client"),c=new Nr.PrismaClient;var d=class{async show(r){return await c.user.findUnique({where:{id:r}})}};var N=U(require("jsonwebtoken")),hr=class{constructor(r){this.showUserPerUserIdRepository=r}async validAuth(r){let[,e]=r.split(" ");if(!N.default.verify(e,process.env.TOKEN_SECRET??""))throw Error("Invalid token");let{id:o,email:a}=N.default.verify(e,process.env.TOKEN_SECRET??""),i=await this.showUserPerUserIdRepository?.show(o);if(a!==i?.email)throw Error("Invalid token");return o}async authentication(r,e){if(!await r.comparePasswords(e))throw Error("Invalid password");return N.default.sign({id:r.userId,email:r.userEmail},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}async authenticationProvider(r,e){return N.default.sign({id:r,email:e},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}},I=hr;var w=async(t,r,e)=>{let{authorization:s}=t.headers;try{let o=new d;if(!s)return r.status(401).json({errors:["Login required"]});let i=await new I(o).validAuth(s);return t.params={...t.params,userId:i},e()}catch{return r.status(401).json({error:"Token expired or invalid"})}};var v=require("zod");var vr=require("uuid");var wr=U(require("bcrypt")),l=class{get userEmail(){return this.props.userEmail}get userFullName(){return this.props.userFullName}get userPassword(){return this.props.userPassword}get userId(){return this.props.userId}set hashPasswordToUserPassword(r){this.props.userPassword=r}set updateUserFullName(r){this.props.userFullName=r}set updateUserEmail(r){this.props.userEmail=r}constructor(r){this.props=r}async encryptedPassword(r){return await wr.default.hash(r,10)}async comparePasswords(r){return await wr.default.compare(r,this.userPassword)}async updatePassword(r,e,s){if(!await this.comparePasswords(r))throw Error("Invalid password");if(e!==s)throw Error("Password confirmation must be the same as password");let a=await this.encryptedPassword(e);this.props.userPassword=a}};var j=class{constructor(r,e){this.createUserRepository=r;this.showUserperEmailRepository=e}async execute({userEmail:r,userFullName:e,userPassword:s}){if(await this.showUserperEmailRepository.show(r))throw Error("Email in use");let a=(0,vr.v4)(),i=new l({userEmail:r,userFullName:e,userId:a,userPassword:s}),n=await i.encryptedPassword(s);return i.hashPasswordToUserPassword=n,await this.createUserRepository.create(i),i}};var F=class{async create(r){let{userEmail:e,userFullName:s,userPassword:o,userId:a}=r,i=await c.user.create({data:{email:e,fullName:s,id:a,password_hash:o}});if(!i)throw Error("N\xE3o foi possivel criar o usuario");return i}};var E=class{async show(r){return await c.user.findUnique({where:{email:r}})}};var ee=v.z.object({email:v.z.string().email(),fullName:v.z.string(),password:v.z.string()}),q=class{async handle(r,e,s){try{let{email:o,fullName:a,password:i}=ee.parse(r.body),n=new F,p=new E,u=await new j(n,p).execute({userEmail:o,userFullName:a,userPassword:i});return e.status(200).json({email:u.userEmail,fullName:u.userFullName})}catch(o){s(o)}}};var b=class{constructor(r){this.showUserRepository=r}async execute(r){let e=await this.showUserRepository.show(r);if(!e)throw Error("User not found");return new l({userEmail:e.email,userFullName:e.fullName,userId:e.id,userPassword:e.password_hash})}};var lr=require("zod"),oe=lr.z.object({userId:lr.z.string()}),_=class{async handle(r,e,s){try{let{userId:o}=oe.parse(r.params),a=new d,n=await new b(a).execute(o);return e.status(200).json({email:n.userEmail,fullName:n.userFullName})}catch(o){s(o)}}};var R=require("zod");var L=class{constructor(r,e){this.showUserPerUserIdRepository=r;this.updateUserRepository=e}async handle({userId:r,email:e,fullName:s,oldPassword:o,newPassword:a,newPasswordConfirmation:i}){let n=await this.showUserPerUserIdRepository.show(r);if(!n)throw Error("User not found");let p=new l({userId:n.id,userEmail:n.email,userFullName:n.fullName,userPassword:n.password_hash});return s&&(p.updateUserFullName=s),a&&o&&i&&await p.updatePassword(o,a,i),e&&(p.updateUserEmail=e),await this.updateUserRepository.update({userId:p.userId,email:p.userEmail,fullName:p.userFullName,newPassword:p.userPassword})}};var A=class{async update({email:r,fullName:e,newPassword:s,userId:o}){return await c.user.update({where:{id:o},data:{email:r,fullName:e,password_hash:s}})}};var se=R.z.object({email:R.z.string().email().optional(),oldPassword:R.z.string().optional(),newPassword:R.z.string().optional(),newPasswordConfirmation:R.z.string().optional(),fullName:R.z.string().optional()}),te=R.z.object({userId:R.z.string()}),z=class{async handle(r,e,s){try{let{email:o,newPassword:a,newPasswordConfirmation:i,oldPassword:n,fullName:p}=se.parse(r.body),{userId:m}=te.parse(r.params);if(a){if(!i)throw Error("newPasswordConfirmation is required to update password");if(!n)throw Error("oldPassword is required to update password")}if(!o&&!a&&!i&&!n&&!p)throw Error("Missing data");let u=new d,x=new A,S=new L(u,x),{email:Er,fullName:dr,id:Jr}=await S.handle({userId:m,email:o,fullName:p,newPassword:a,newPasswordConfirmation:i,oldPassword:n});return e.status(200).json({user:{email:Er,fullName:dr,id:Jr}})}catch(o){s(o)}}};var T=(0,Tr.Router)(),ae=new q,ie=new _,ne=new z;T.post("/users",ae.handle);T.get("/users",w,ie.handle);T.put("/users",w,ne.handle);var Lr=require("express");var _r=require("uuid");var B=U(require("crypto")),jr="aes-256-gcm",Fr=Buffer.from(process.env.SECRET_CRYPTO??"","hex"),Cr=B.default.randomBytes(16),qr=t=>{try{let r=B.default.createCipheriv(jr,Fr,Cr),e=Buffer.concat([r.update(t.toString()),r.final()]),s=r.getAuthTag();return{iv:Cr.toString("hex"),content:e.toString("hex"),tag:s.toString("hex")}}catch{throw Error("Erro ao criptografar os dados")}},br=t=>{try{let r=B.default.createDecipheriv(jr,Fr,Buffer.from(t.iv,"hex"));r.setAuthTag(Buffer.from(t.tag,"hex"));let e=Buffer.from(t.content,"hex");return Buffer.concat([r.update(e),r.final()]).toString("utf8")}catch{throw new Error("Erro ao descriptografar os dados.")}};var h=class{get storageId(){return this.props.storageId}get password(){return this.props.password}get account(){return this.props.account}get usageLocation(){return this.props.usageLocation}get link(){return this.props.link}get description(){return this.props.description}get userId(){return this.props.userId}constructor(r){this.props=r}showPassword(r){let[e,s,o]=r.split(":");return br({iv:e,content:s,tag:o})}};var D=class{constructor(r){this.storageRepository=r}async execute({account:r,password:e,usageLocation:s,description:o,link:a,userId:i}){let n=(0,_r.v4)(),{iv:p,content:m,tag:u}=qr(e),x=`${p}:${m}:${u}`,S=new h({password:x,account:r,usageLocation:s,description:o,link:a,userId:i,storageId:n});return await this.storageRepository.create(S),S}};var M=class{async create(r){let{account:e,description:s,link:o,password:a,usageLocation:i,userId:n,storageId:p}=r,m=await c.storage.create({data:{account:e,id:p,password:a,usageLocation:i,description:s,link:o,userId:n}});if(!m)throw Error("N\xE3o foi possivel armazenar os dados");return m}};var y=require("zod"),pe=y.z.object({password:y.z.string(),account:y.z.string(),usageLocation:y.z.string(),link:y.z.string(),description:y.z.string()}),ce=y.z.object({userId:y.z.string()}),O=class{async handle(r,e,s){try{let{password:o,account:a,usageLocation:i,link:n,description:p}=pe.parse(r.body),{userId:m}=ce.parse(r.params),u=new M,S=await new D(u).execute({account:a,password:o,usageLocation:i,description:p,link:n,userId:m});return e.status(200).json(S)}catch(o){s(o)}}};var K=class{async index(r){return await c.storage.findMany({where:{userId:r}})}};var V=class{constructor(r){this.indexStorageRepository=r}async execute(r){let e=await this.indexStorageRepository.index(r),s=[];return e.forEach(o=>{let a=new h({account:o.account,password:"",storageId:o.id,usageLocation:o.usageLocation,userId:o.userId,description:o.description||void 0,link:o.link||void 0});s.push(a)}),s}};var gr=require("zod"),me=gr.z.object({userId:gr.z.string()}),H=class{async handle(r,e,s){try{let{userId:o}=me.parse(r.params);if(!o)return e.status(401).json({error:"Login required"});let a=new K,n=await new V(a).execute(o);return e.status(200).json({storages:n})}catch(o){s(o)}}};var g=class{async show(r,e){return await c.storage.findFirst({where:{AND:{id:r,userId:e}}})}};var $=class{constructor(r){this.showStorageRepository=r}async execute(r,e){let s=await this.showStorageRepository.show(r,e);if(!s)throw Error("Storage not found");return new h({account:s.account,password:"",storageId:s.id,usageLocation:s.usageLocation,userId:s.userId,description:s.description||"",link:s.link||""})}};var J=require("zod"),ue=J.z.object({storageId:J.z.string(),userId:J.z.string()}),X=class{async handle(r,e,s){try{let{storageId:o,userId:a}=ue.parse(r.params),i=new g,p=await new $(i).execute(o,a);return e.status(200).json(p)}catch(o){s(o)}}};var Z=class{async update({account:r,description:e,link:s,usageLocation:o,storageId:a,password:i}){return await c.storage.update({where:{id:a},data:{account:r,description:e,link:s,usageLocation:o,password:i}})}};var Y=class{constructor(r,e){this.updateStorageReposirory=r;this.showStorageRepository=e}async execute({storageId:r,account:e,description:s,link:o,usageLocation:a,userId:i,password:n}){if(!await this.showStorageRepository.show(r,i))throw Error("Storage not found");let m=await this.updateStorageReposirory.update({storageId:r,account:e,userId:i,description:s,link:o,usageLocation:a,password:n});return new h({account:m.account,password:"",storageId:m.id,usageLocation:m.usageLocation,userId:m.userId,description:m.description||"",link:m.link||""})}};var f=require("zod"),de=f.z.object({account:f.z.string().optional(),usageLocation:f.z.string().optional(),description:f.z.string().optional(),link:f.z.string().optional(),password:f.z.string().optional()}),he=f.z.object({userId:f.z.string(),storageId:f.z.string()}),G=class{async handle(r,e,s){try{let{account:o,usageLocation:a,description:i,link:n,password:p}=de.parse(r.body),{userId:m,storageId:u}=he.parse(r.params);if(!o&&!a&&!i&&!n)return e.status(400).json({error:"Missing data"});let x=new Z,S=new g,dr=await new Y(x,S).execute({account:o,storageId:u,userId:m,description:i,link:n,usageLocation:a,password:p});return e.status(200).json({storage:dr})}catch(o){s(o)}}};var Q=class{async delete(r){await c.storage.delete({where:{id:r}})}};var W=class{constructor(r,e){this.deleteStorageRepository=r;this.showStorageRepository=e}async execute(r,e){if(!await this.showStorageRepository.show(r,e))throw Error("Storage not found");await this.deleteStorageRepository.delete(r)}};var rr=require("zod"),we=rr.z.object({userId:rr.z.string(),storageId:rr.z.string()}),er=class{async handle(r,e,s){try{let{userId:o,storageId:a}=we.parse(r.params),i=new Q,n=new g;return await new W(i,n).execute(a,o),e.status(200).json({})}catch(o){s(o)}}};var le=new O,ge=new H,fe=new X,Re=new G,ye=new er,P=(0,Lr.Router)();P.post("/storages",w,le.handle);P.get("/storages",w,ge.handle);P.get("/storages/:storageId",w,fe.handle);P.put("/storages/:storageId",w,Re.handle);P.delete("/storages/:storageId",w,ye.handle);var Br=require("express");var Ar=U(require("dayjs")),zr=require("uuid"),or=class{constructor(r,e,s){this.showUserPerEmailRepository=r;this.createRefreshTokenRepository=e;this.deleteRefreshTokenRepository=s}async execute({email:r,password:e}){let s=await this.showUserPerEmailRepository.show(r);if(!s)throw Error("User not found");let o=new l({userEmail:s.email,userFullName:s.fullName,userId:s.id,userPassword:s.password_hash}),a=new I;await this.deleteRefreshTokenRepository.delete(s.id);let i=await a.authentication(o,e),n=(0,zr.v4)(),p=(0,Ar.default)().add(7,"days").unix(),m=await this.createRefreshTokenRepository.create({expiresIn:p,id:n,userId:o.userId});return{token:i,refreshToken:m}}};var sr=class{async create({expiresIn:r,id:e,userId:s}){return await c.refresh_Token.create({data:{expiresIn:r,id:e,userId:s}})}};var tr=class{async delete(r){await c.refresh_Token.deleteMany({where:{userId:r}})}};var ar=require("zod"),Se=ar.z.object({email:ar.z.string().email(),password:ar.z.string()}),ir=class{async handle(r,e,s){try{let{email:o,password:a}=Se.parse(r.body);if(!o||!a)return e.status(400).json({error:"Missing data"});let i=new E,n=new sr,p=new tr,u=await new or(i,n,p).execute({email:o,password:a});return e.status(200).json(u)}catch(o){s(o)}}};var fr=(0,Br.Router)(),Ue=new ir;fr.post("/auth",Ue.handle);var Mr=require("express");var Dr=U(require("bcrypt")),nr=class{constructor(r,e){this.showStorageRepository=r;this.showUserPerUserIdRepository=e}async execute(r,e,s){let o=await this.showStorageRepository.show(r,e);if(!o)throw Error("Storage not found");let a=new h({account:o.account,password:o.password,storageId:o.id,usageLocation:o.usageLocation,userId:o.userId,description:o.description??"",link:o.link??""}),i=await this.showUserPerUserIdRepository.show(e);if(!i)throw Error("User not found");if(!await Dr.default.compare(s,i.password_hash))throw Error("Invalid password");return a.showPassword(a.password)}};var k=require("zod"),Pe=k.z.object({password:k.z.string()}),xe=k.z.object({storageId:k.z.string(),userId:k.z.string()}),pr=class{async handle(r,e,s){try{let{password:o}=Pe.parse(r.body),{storageId:a,userId:i}=xe.parse(r.params);if(!o)return e.status(400).json({error:"Missing data"});let n=new g,p=new d,u=await new nr(n,p).execute(a,i,o);return e.status(200).json({descryptedPassword:u})}catch(o){s(o)}}};var Rr=(0,Mr.Router)(),Ie=new pr;Rr.post("/passwords/storages/:storageId",w,Ie.handle);var Or=require("express");var yr=U(require("dayjs"));var cr=class{constructor(r,e){this.showRefreshTokenRepository=r;this.showUserPerUserIdRepository=e}async execute(r){let e=await this.showRefreshTokenRepository.show(r);if(!e)throw Error("Refresh token invalid");let s=await this.showUserPerUserIdRepository.show(e.userId);if(!s)throw Error("User not found");let o=new I;if((0,yr.default)().isAfter(yr.default.unix(e.expiresIn)))throw Error("Refresh_token expired");return await o.authenticationProvider(e.userId,s.email)}};var mr=class{async show(r){return await c.refresh_Token.findFirst({where:{id:r}})}};var Sr=require("zod");var Ee=Sr.z.object({refresh_token:Sr.z.string()}),ur=class{async handle(r,e,s){try{let{refresh_token:o}=Ee.parse(r.body),a=new mr,i=new d,p=await new cr(a,i).execute(o);return e.status(200).json({token:p})}catch(o){s(o)}}};var Ur=(0,Or.Router)(),ke=new ur;Ur.post("/refresh-token",ke.handle);var Pr=require("@prisma/client"),Kr=require("zod"),Vr=require("zod-validation-error"),Hr=async(t,r,e,s)=>{if(t instanceof Pr.Prisma.PrismaClientInitializationError)return e.status(500).json({error:"Failed to connect to the database"});if(t instanceof Pr.Prisma.PrismaClientKnownRequestError)return t.code==="P2025"?e.status(400).json({error:"The record no exists"}):t.code==="P2002"?e.status(400).json({error:"Record already exists"}):e.status(400).json({error:t.message});if(t instanceof Kr.ZodError){let{message:o}=(0,Vr.fromZodError)(t);return e.status(400).json({error:o})}if(t instanceof Error)return t.message==="invalid token"?e.status(401).json({error:t.message}):e.status(400).json({error:t.message});if(t)return e.status(400).json({error:"An error occurred"});s()};var $r=U(require("cors")),Ir=class{constructor(){this.app=(0,xr.default)(),this._middlewares(),this._router(),this._lastMiddlewares()}_middlewares(){this.app.use(xr.default.json()),this.app.use((0,$r.default)())}_lastMiddlewares(){this.app.use(Hr)}_router(){this.app.use(T),this.app.use(P),this.app.use(fr),this.app.use(Rr),this.app.use(Ur)}},Ne=new Ir;
