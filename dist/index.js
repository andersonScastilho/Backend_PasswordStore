"use strict";var Xr=Object.create;var Er=Object.defineProperty;var Zr=Object.getOwnPropertyDescriptor;var Yr=Object.getOwnPropertyNames;var Gr=Object.getPrototypeOf,Qr=Object.prototype.hasOwnProperty;var Wr=(t,r,e,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of Yr(r))!Qr.call(t,o)&&o!==e&&Er(t,o,{get:()=>r[o],enumerable:!(s=Zr(r,o))||s.enumerable});return t};var U=(t,r,e)=>(e=t!=null?Xr(Gr(t)):{},Wr(r||!t||!t.__esModule?Er(e,"default",{value:t,enumerable:!0}):e,t));var Pr=U(require("express"));var Nr=require("express");var kr=require("@prisma/client"),c=new kr.PrismaClient;var d=class{async show(r){return await c.user.findUnique({where:{id:r}})}};var v=U(require("jsonwebtoken")),dr=class{constructor(r){this.showUserPerUserIdRepository=r}async validAuth(r){let[,e]=r.split(" ");if(!v.default.verify(e,process.env.TOKEN_SECRET??""))throw Error("Invalid token");let{id:o,email:a}=v.default.verify(e,process.env.TOKEN_SECRET??""),i=await this.showUserPerUserIdRepository?.show(o);if(a!==i?.email)throw Error("Invalid token");return o}async authentication(r,e){if(!await r.comparePasswords(e))throw Error("Invalid password");return v.default.sign({id:r.userId,email:r.userEmail},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}async authenticationProvider(r,e){return v.default.sign({id:r,email:e},process.env.TOKEN_SECRET??"",{expiresIn:process.env.TOKEN_EXPIRATION})}},I=dr;var w=async(t,r,e)=>{let{authorization:s}=t.headers;try{let o=new d;if(!s)return r.status(401).json({errors:["Login required"]});let i=await new I(o).validAuth(s);return t.params={...t.params,userId:i},e()}catch{return r.status(401).json({error:"Token expired or invalid"})}};var N=require("zod");var vr=require("uuid");var hr=U(require("bcrypt")),l=class{get userEmail(){return this.props.userEmail}get userFullName(){return this.props.userFullName}get userPassword(){return this.props.userPassword}get userId(){return this.props.userId}set hashPasswordToUserPassword(r){this.props.userPassword=r}set updateUserFullName(r){this.props.userFullName=r}set updateUserEmail(r){this.props.userEmail=r}constructor(r){this.props=r}async encryptedPassword(r){return await hr.default.hash(r,10)}async comparePasswords(r){return await hr.default.compare(r,this.userPassword)}async updatePassword(r,e,s){if(!await this.comparePasswords(r))throw Error("Invalid password");if(e!==s)throw Error("Password confirmation must be the same as password");let a=await this.encryptedPassword(e);this.props.userPassword=a}};var C=class{constructor(r,e){this.createUserRepository=r;this.showUserperEmailRepository=e}async execute({userEmail:r,userFullName:e,userPassword:s}){if(await this.showUserperEmailRepository.show(r))throw Error("Email in use");let a=(0,vr.v4)(),i=new l({userEmail:r,userFullName:e,userId:a,userPassword:s}),n=await i.encryptedPassword(s);return i.hashPasswordToUserPassword=n,await this.createUserRepository.create(i),i}};var j=class{async create(r){let{userEmail:e,userFullName:s,userPassword:o,userId:a}=r,i=await c.user.create({data:{email:e,fullName:s,id:a,password_hash:o}});if(!i)throw Error("N\xE3o foi possivel criar o usuario");return i}};var E=class{async show(r){return await c.user.findUnique({where:{email:r}})}};var re=N.z.object({email:N.z.string().email(),fullName:N.z.string(),password:N.z.string()}),F=class{async handle(r,e,s){try{let{email:o,fullName:a,password:i}=re.parse(r.body),n=new j,p=new E,u=await new C(n,p).execute({userEmail:o,userFullName:a,userPassword:i});return e.status(200).json({email:u.userEmail,fullName:u.userFullName})}catch(o){s(o)}}};var q=class{constructor(r){this.showUserRepository=r}async execute(r){let e=await this.showUserRepository.show(r);if(!e)throw Error("User not found");return new l({userEmail:e.email,userFullName:e.fullName,userId:e.id,userPassword:e.password_hash})}};var wr=require("zod"),ee=wr.z.object({userId:wr.z.string()}),b=class{async handle(r,e,s){try{let{userId:o}=ee.parse(r.params),a=new d,n=await new q(a).execute(o);return e.status(200).json({email:n.userEmail,fullName:n.userFullName})}catch(o){s(o)}}};var R=require("zod");var _=class{constructor(r,e){this.showUserPerUserIdRepository=r;this.updateUserRepository=e}async handle({userId:r,email:e,fullName:s,oldPassword:o,newPassword:a,newPasswordConfirmation:i}){let n=await this.showUserPerUserIdRepository.show(r);if(!n)throw Error("User not found");let p=new l({userId:n.id,userEmail:n.email,userFullName:n.fullName,userPassword:n.password_hash});return s&&(p.updateUserFullName=s),a&&o&&i&&await p.updatePassword(o,a,i),e&&(p.updateUserEmail=e),await this.updateUserRepository.update({userId:p.userId,email:p.userEmail,fullName:p.userFullName,newPassword:p.userPassword})}};var L=class{async update({email:r,fullName:e,newPassword:s,userId:o}){return await c.user.update({where:{id:o},data:{email:r,fullName:e,password_hash:s}})}};var oe=R.z.object({email:R.z.string().email().optional(),oldPassword:R.z.string().optional(),newPassword:R.z.string().optional(),newPasswordConfirmation:R.z.string().optional(),fullName:R.z.string().optional()}),se=R.z.object({userId:R.z.string()}),A=class{async handle(r,e,s){try{let{email:o,newPassword:a,newPasswordConfirmation:i,oldPassword:n,fullName:p}=oe.parse(r.body),{userId:m}=se.parse(r.params);if(a){if(!i)throw Error("newPasswordConfirmation is required to update password");if(!n)throw Error("oldPassword is required to update password")}if(!o&&!a&&!i&&!n&&!p)throw Error("Missing data");let u=new d,x=new L,S=new _(u,x),{email:Ir,fullName:ur,id:Jr}=await S.handle({userId:m,email:o,fullName:p,newPassword:a,newPasswordConfirmation:i,oldPassword:n});return e.status(200).json({user:{email:Ir,fullName:ur,id:Jr}})}catch(o){s(o)}}};var T=(0,Nr.Router)(),te=new F,ae=new b,ie=new A;T.post("/users",te.handle);T.get("/users",w,ae.handle);T.put("/users",w,ie.handle);var _r=require("express");var br=require("uuid");var z=U(require("crypto")),Cr="aes-256-gcm",jr=Buffer.from(process.env.SECRET_CRYPTO??"","hex"),Tr=z.default.randomBytes(16),Fr=t=>{try{let r=z.default.createCipheriv(Cr,jr,Tr),e=Buffer.concat([r.update(t.toString()),r.final()]),s=r.getAuthTag();return{iv:Tr.toString("hex"),content:e.toString("hex"),tag:s.toString("hex")}}catch{throw Error("Erro ao criptografar os dados")}},qr=t=>{try{let r=z.default.createDecipheriv(Cr,jr,Buffer.from(t.iv,"hex"));r.setAuthTag(Buffer.from(t.tag,"hex"));let e=Buffer.from(t.content,"hex");return Buffer.concat([r.update(e),r.final()]).toString("utf8")}catch{throw new Error("Erro ao descriptografar os dados.")}};var h=class{get storageId(){return this.props.storageId}get password(){return this.props.password}get account(){return this.props.account}get usageLocation(){return this.props.usageLocation}get link(){return this.props.link}get description(){return this.props.description}get userId(){return this.props.userId}constructor(r){this.props=r}showPassword(r){let[e,s,o]=r.split(":");return qr({iv:e,content:s,tag:o})}};var B=class{constructor(r){this.storageRepository=r}async execute({account:r,password:e,usageLocation:s,description:o,link:a,userId:i}){let n=(0,br.v4)(),{iv:p,content:m,tag:u}=Fr(e),x=`${p}:${m}:${u}`,S=new h({password:x,account:r,usageLocation:s,description:o,link:a,userId:i,storageId:n});return await this.storageRepository.create(S),S}};var D=class{async create(r){let{account:e,description:s,link:o,password:a,usageLocation:i,userId:n,storageId:p}=r,m=await c.storage.create({data:{account:e,id:p,password:a,usageLocation:i,description:s,link:o,userId:n}});if(!m)throw Error("N\xE3o foi possivel armazenar os dados");return m}};var y=require("zod"),ne=y.z.object({password:y.z.string(),account:y.z.string(),usageLocation:y.z.string(),link:y.z.string(),description:y.z.string()}),pe=y.z.object({userId:y.z.string()}),M=class{async handle(r,e,s){try{let{password:o,account:a,usageLocation:i,link:n,description:p}=ne.parse(r.body),{userId:m}=pe.parse(r.params),u=new D,S=await new B(u).execute({account:a,password:o,usageLocation:i,description:p,link:n,userId:m});return e.status(200).json(S)}catch(o){s(o)}}};var O=class{async index(r){return await c.storage.findMany({where:{userId:r}})}};var K=class{constructor(r){this.indexStorageRepository=r}async execute(r){let e=await this.indexStorageRepository.index(r),s=[];return e.forEach(o=>{let a=new h({account:o.account,password:"",storageId:o.id,usageLocation:o.usageLocation,userId:o.userId,description:o.description||void 0,link:o.link||void 0});s.push(a)}),s}};var lr=require("zod"),ce=lr.z.object({userId:lr.z.string()}),V=class{async handle(r,e,s){try{let{userId:o}=ce.parse(r.params);if(!o)return e.status(401).json({error:"Login required"});let a=new O,n=await new K(a).execute(o);return e.status(200).json({storages:n})}catch(o){s(o)}}};var g=class{async show(r,e){return await c.storage.findFirst({where:{AND:{id:r,userId:e}}})}};var H=class{constructor(r){this.showStorageRepository=r}async execute(r,e){let s=await this.showStorageRepository.show(r,e);if(!s)throw Error("Storage not found");return new h({account:s.account,password:"",storageId:s.id,usageLocation:s.usageLocation,userId:s.userId,description:s.description||"",link:s.link||""})}};var $=require("zod"),me=$.z.object({storageId:$.z.string(),userId:$.z.string()}),J=class{async handle(r,e,s){try{let{storageId:o,userId:a}=me.parse(r.params),i=new g,p=await new H(i).execute(o,a);return e.status(200).json(p)}catch(o){s(o)}}};var X=class{async update({account:r,description:e,link:s,usageLocation:o,storageId:a,password:i}){return await c.storage.update({where:{id:a},data:{account:r,description:e,link:s,usageLocation:o,password:i}})}};var Z=class{constructor(r,e){this.updateStorageReposirory=r;this.showStorageRepository=e}async execute({storageId:r,account:e,description:s,link:o,usageLocation:a,userId:i,password:n}){if(!await this.showStorageRepository.show(r,i))throw Error("Storage not found");let m=await this.updateStorageReposirory.update({storageId:r,account:e,userId:i,description:s,link:o,usageLocation:a,password:n});return new h({account:m.account,password:"",storageId:m.id,usageLocation:m.usageLocation,userId:m.userId,description:m.description||"",link:m.link||""})}};var f=require("zod"),ue=f.z.object({account:f.z.string().optional(),usageLocation:f.z.string().optional(),description:f.z.string().optional(),link:f.z.string().optional(),password:f.z.string().optional()}),de=f.z.object({userId:f.z.string(),storageId:f.z.string()}),Y=class{async handle(r,e,s){try{let{account:o,usageLocation:a,description:i,link:n,password:p}=ue.parse(r.body),{userId:m,storageId:u}=de.parse(r.params);if(!o&&!a&&!i&&!n)return e.status(400).json({error:"Missing data"});let x=new X,S=new g,ur=await new Z(x,S).execute({account:o,storageId:u,userId:m,description:i,link:n,usageLocation:a,password:p});return e.status(200).json({storage:ur})}catch(o){s(o)}}};var G=class{async delete(r){await c.storage.delete({where:{id:r}})}};var Q=class{constructor(r,e){this.deleteStorageRepository=r;this.showStorageRepository=e}async execute(r,e){if(!await this.showStorageRepository.show(r,e))throw Error("Storage not found");await this.deleteStorageRepository.delete(r)}};var W=require("zod"),he=W.z.object({userId:W.z.string(),storageId:W.z.string()}),rr=class{async handle(r,e,s){try{let{userId:o,storageId:a}=he.parse(r.params),i=new G,n=new g;return await new Q(i,n).execute(a,o),e.status(200).json({})}catch(o){s(o)}}};var we=new M,le=new V,ge=new J,fe=new Y,Re=new rr,P=(0,_r.Router)();P.post("/storages",w,we.handle);P.get("/storages",w,le.handle);P.get("/storages/:storageId",w,ge.handle);P.put("/storages/:storageId",w,fe.handle);P.delete("/storages/:storageId",w,Re.handle);var zr=require("express");var Lr=U(require("dayjs")),Ar=require("uuid"),er=class{constructor(r,e,s){this.showUserPerEmailRepository=r;this.createRefreshTokenRepository=e;this.deleteRefreshTokenRepository=s}async execute({email:r,password:e}){let s=await this.showUserPerEmailRepository.show(r);if(!s)throw Error("User not found");let o=new l({userEmail:s.email,userFullName:s.fullName,userId:s.id,userPassword:s.password_hash}),a=new I;await this.deleteRefreshTokenRepository.delete(s.id);let i=await a.authentication(o,e),n=(0,Ar.v4)(),p=(0,Lr.default)().add(7,"day").unix(),m=await this.createRefreshTokenRepository.create({expiresIn:p,id:n,userId:o.userId});return{token:i,refreshToken:m}}};var or=class{async create({expiresIn:r,id:e,userId:s}){return await c.refresh_Token.create({data:{expiresIn:r,id:e,userId:s}})}};var sr=class{async delete(r){await c.refresh_Token.deleteMany({where:{userId:r}})}};var tr=require("zod"),ye=tr.z.object({email:tr.z.string().email(),password:tr.z.string()}),ar=class{async handle(r,e,s){try{let{email:o,password:a}=ye.parse(r.body);if(!o||!a)return e.status(400).json({error:"Missing data"});let i=new E,n=new or,p=new sr,u=await new er(i,n,p).execute({email:o,password:a});return e.status(200).json(u)}catch(o){s(o)}}};var gr=(0,zr.Router)(),Se=new ar;gr.post("/auth",Se.handle);var Dr=require("express");var Br=U(require("bcrypt")),ir=class{constructor(r,e){this.showStorageRepository=r;this.showUserPerUserIdRepository=e}async execute(r,e,s){let o=await this.showStorageRepository.show(r,e);if(!o)throw Error("Storage not found");let a=new h({account:o.account,password:o.password,storageId:o.id,usageLocation:o.usageLocation,userId:o.userId,description:o.description??"",link:o.link??""}),i=await this.showUserPerUserIdRepository.show(e);if(!i)throw Error("User not found");if(!await Br.default.compare(s,i.password_hash))throw Error("Invalid password");return a.showPassword(a.password)}};var k=require("zod"),Ue=k.z.object({password:k.z.string()}),Pe=k.z.object({storageId:k.z.string(),userId:k.z.string()}),nr=class{async handle(r,e,s){try{let{password:o}=Ue.parse(r.body),{storageId:a,userId:i}=Pe.parse(r.params);if(!o)return e.status(400).json({error:"Missing data"});let n=new g,p=new d,u=await new ir(n,p).execute(a,i,o);return e.status(200).json({descryptedPassword:u})}catch(o){s(o)}}};var fr=(0,Dr.Router)(),xe=new nr;fr.post("/passwords/storages/:storageId",w,xe.handle);var Mr=require("express");var Rr=U(require("dayjs"));var pr=class{constructor(r,e){this.showRefreshTokenRepository=r;this.showUserPerUserIdRepository=e}async execute(r){let e=await this.showRefreshTokenRepository.show(r);if(!e)throw Error("Refresh token invalid");let s=await this.showUserPerUserIdRepository.show(e.userId);if(!s)throw Error("User not found");let o=new I;if((0,Rr.default)().isAfter(Rr.default.unix(e.expiresIn)))throw Error("Refresh_token expired");return await o.authenticationProvider(e.userId,s.email)}};var cr=class{async show(r){return await c.refresh_Token.findFirst({where:{id:r}})}};var yr=require("zod");var Ie=yr.z.object({refresh_token:yr.z.string()}),mr=class{async handle(r,e,s){try{let{refresh_token:o}=Ie.parse(r.body),a=new cr,i=new d,p=await new pr(a,i).execute(o);return e.status(200).json({token:p})}catch(o){s(o)}}};var Sr=(0,Mr.Router)(),Ee=new mr;Sr.post("/refresh-token",Ee.handle);var Ur=require("@prisma/client"),Or=require("zod"),Kr=require("zod-validation-error"),Vr=async(t,r,e,s)=>{if(t instanceof Ur.Prisma.PrismaClientInitializationError)return e.status(500).json({error:"Failed to connect to the database"});if(t instanceof Ur.Prisma.PrismaClientKnownRequestError)return t.code==="P2025"?e.status(400).json({error:"The record no exists"}):t.code==="P2002"?e.status(400).json({error:"Record already exists"}):e.status(400).json({error:t.message});if(t instanceof Or.ZodError){let{message:o}=(0,Kr.fromZodError)(t);return e.status(400).json({error:o})}if(t instanceof Error)return t.message==="invalid token"?e.status(401).json({error:t.message}):e.status(400).json({error:t.message});if(t)return e.status(400).json({error:"An error occurred"});s()};var Hr=U(require("cors")),xr=class{constructor(){this.app=(0,Pr.default)(),this._middlewares(),this._router(),this._lastMiddlewares()}_middlewares(){this.app.use(Pr.default.json()),this.app.use((0,Hr.default)())}_lastMiddlewares(){this.app.use(Vr)}_router(){this.app.use(T),this.app.use(P),this.app.use(gr),this.app.use(fr),this.app.use(Sr)}},$r=new xr;$r.app.listen(3002,()=>{console.log("Servidor rodando na porta 3000 ")});
